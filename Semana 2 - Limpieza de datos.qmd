---
title: "Semana 2 - Limpieza de datos"
author: "Mariano Prado"
date: "29 de agosto, 2025"
format: html
editor: visual
output:
  html_notebook:
    toc: yes                # Crea tabla de contenido
    toc_float:             
       collapsed: yes       # Aparecen solo con los encabezados de nivel superior
       smooth_scroll: no    # Desplazamientos "animados" en vez de directos
    number_sections: yes    # numerar secciones y subsecciones
    theme: journal      # Tema
  html_document:
    toc: yes
    df_print: paged
---

# Cargar los datos

## Desde un Excel

```{r}
# rm(list = ls()) # Borra todos los objetos
```

```{r}
help("mean")
```

```{r}
# file.choose()
```

"K:\\Mi unidad\\1. Clases en UTEC\\Estadistica y Probabilidades 2025-2\\Grupo 6\\Datos_Diversos_Pasado.xlsx"

```{r}
library(readxl)  # Llama la librería que carga los datos desde un Excel
Datos_Diversos <- read_excel("K:\\Mi unidad\\1. Clases en UTEC\\Estadistica y Probabilidades 2025-2\\Grupo 6\\Datos_Diversos_Pasado.xlsx") #Carga los datos
head(Datos_Diversos)  # Llama los datos
```

```{r}
str(Datos_Diversos)
```

```{r}
# library(readxl)
# Datos_Diversos <- read_excel("~/R/Datos_Diversos_Pasado.xlsx")
# Datos_Diversos
```

## Desde un CSV (read_csv)

Comentar rápido: Ctrl + mayús + c

Dirección alterna del directorio de trabajo: "\~/R/Datos_Diversos_Pasado.csv"

```{r}
library(readr)
Datos_Diversos <- read_csv("I:\\My Drive\\・🎓University\\CC1105・Statistics and Probabilities 1\\Datos_Diversos_Pasado.csv")
Datos_Diversos
```

# Revizar los datos

## Resumen general de la tabla de datos

El comando `str` devuelve un resumen del tipo de variable que asume RStudio.

```{r}
str(Datos_Diversos)
```

## Resumen de una sola variable

Resumen de una variable cuantitativa

```{r}
summary(Datos_Diversos$Edad)
```

Resumen de una variable cualitativa
Always cuenta los NA, que es importante.
```{r}
table(Datos_Diversos$Sexo, useNA = "always")
```

## Revizar el inicio y el final de los datos

```{r}
# Lee las 6 primeras filas de la base de datos
head(Datos_Diversos)
```

```{r}
# Lee las 6 últimas filas de la base de datos
tail(Datos_Diversos)
```

# Limpieza de los datos

## Datos incompletos / completos

`is.na()`: Este comando detecta los datos incompletos (NA).   `sum`: Suma la cantidad de datos incompletos.\
`!`: Es el operador negación

TRUE = 1\
FALSE = 0

```{r}
sum(TRUE)
sum(FALSE)
```

```{r}
TRUE + TRUE
TRUE + FALSE
```

```{r}
!FALSE
```

```{r}
# Cantidad de datos nulos (NA) /incompletos de todo el dataframe
sum(is.na(Datos_Diversos))
```

```{r}
# Cantidad de datos nulos (NA) /incompleto de una variable (Edad)
sum(is.na(Datos_Diversos$Edad))
```

```{r}
# Cantidad de datos COMPLETOS de todo el dataframe
sum(!is.na(Datos_Diversos))
```

## Filas (observaciones o casos) completos / imcompletos
is.na ve filas para hallar valores nulos.

```{r}
# Cantidad de casos o filas completas
sum(complete.cases(Datos_Diversos))
```

```{r}
sum(!is.na(Datos_Diversos$...20))
```

```{r}
# Cantidad de casos o filas INcompletas
sum(!complete.cases(Datos_Diversos))
```

## Criterios para limpieza de datos

**¿Qué hacer si encontramos una casilla vacía o *(N/A)* o caso incompleto o NULL?**

-   Eliminar a la observación que no sea un **caso completo**. La desventaja es que se puede perder información de otras variables que si son importantes, además de incrementar ligeramente el sesgo ya existente.
-   Ver cual es la variable o columna que tiene la mayor cantidad de datos incompletos y eliminarlo
-   Re-consultar la fuente y completar la información con el valor verídico.
-   **No se debe** completar la información a criterio o al azar, pues se estaría manipulando intencionalmente la información, lo cual no es éticamente correcto.

**¿Qué hacer si encontramos una casilla con un valor evidentemente erróneo?**

-   Eliminar la observación (*ya se explicó sus desventajas*), depende de la cantidad de estas observaciones.
-   Corregir el valor, por el adecuado; para esto podemos consultar con la fuente original (**es lo ideal**), o corregirlo a criterio siempre y cuando el error sea **muy evidente**.

## Librería dplyr

-   Paquete con pocas funciones pero muy poderosas para ordenar datos

-   Parte del tidyverse (Colección de paquetes disponibles en R y orientados a la **manipulación, importación, exploración y visualización de datos**, que se utiliza exhaustivamente en ciencia de datos)

    -   **rename**: Cambia los nombre de las columnas de una base.
    -   **group_by**: (agrupa datos)
    -   **summarize**: (resume datos agrupados)
    -   **filter**: (Encuentra filas con ciertas condiciones)
    -   **select**: junto a **starts_with, ends_with o contains**, selecciona columnas.
    -   **mutate**: (Genera variables nuevas).
    -   **%\>%**: pipeline es un operador (CTRL + SHIFT + m)
    -   **arrange**: ordenar

```{r}
# install.packages("dplyr")   # Instala una librería
library(dplyr)                # Llamar la librería
```

### Funcion "rename"

Cambia los nombre de las columnas de una base de datos.

`rename(base_datos, nombrenuevo1 = nombreviejo1, nombrenuevo2 = nombreviejo2, ... )`

```{r}
# Lista los encabezados del dataframe
names(Datos_Diversos)
```

```{r}
Datos_Diversos_rename <- rename(Datos_Diversos,  # Tabla de datos
                                Periodo=Período
                                ,Codigo = Código
                                ,Seccion = Sección
                                ,Estatura = "Estatura (cm)"
                                ,Peso = "Peso (kg)"  
                                ,Signo = "Signo del zodiaco"
                                ,Tiempo = "Tiempo de reacción" 
                                ,Videojuegos = "Juega videojuegos"
                                ,Deporte = "Hace deporte" 
                                ,Color = "Color favorito"  
                                ,Calzado = "Talla de zapato" 
                                ,Polo = "Talla de polo" 
                                 )
```

```{r}
names(Datos_Diversos_rename)
```

### Funcion "select"

-   Permite ir rápidamente a un subconjunto mediante operaciones basadas en el nombre de las variables.
-   Es útil si se tiene data con muchas variables.

`select(base_datos, variables_a_seleccionar)`

```{r}
# Forma de selección 1
select(Datos_Diversos_rename, Periodo, Edad, Ciclo)
```

```{r}
# Forma de selección 2
select(Datos_Diversos_rename, 1, 2, 3, 4)
```

```{r}
# Forma de selección 3
select(Datos_Diversos_rename, Periodo:Nombre)
```

```{r}
# Forma de selección 4
select(Datos_Diversos_rename, 1:4)
```

```{r}
# Forma de selección 5: Selecciono toda la tabla, menos la columna 2.
select(Datos_Diversos_rename, -2)
```

No quieren la columna 19 y 20
```{r}
select(Datos_Diversos_rename, 1:18)
#select(Datos_Diversos_rename, c(-19,-20))
```

```{r}
Datos_Diversos_rename <- select(Datos_Diversos_rename, 1:18)
names(Datos_Diversos_rename)
```

```{r}
# Filas completas
sum(complete.cases(Datos_Diversos_rename))
```

```{r}
# Filas INcompletas
sum(!complete.cases(Datos_Diversos_rename))
```

### Seleccionar columnas/variables por coincidencia o patrones

El comando **select** tiene potencia en base de datos cuyas variables tienen algún patrón en común, en esos casos se pueden utilizar los argumentos:

-   Patrón 1: `starts_with("...")`, Variables que comienzan con ...

-   Patrón 2: `ends_with("...")`, Variables que terminan con ...

-   Patrón 3: `contains("...")`, Variables que contienen ...

```{r}
# Patrón 1
select(Datos_Diversos_rename, starts_with("c"))
```

```{r}
# Patrón 2
select(Datos_Diversos_rename, ends_with("do"))
```

```{r}
# Patron 3
select(Datos_Diversos_rename, contains("po"))
```

### Función "filter"

`filter(base_datos, condición)`

-   Permite crear o seleccionar subconjuntos de la base con base al resultado de sus variables.

-   Algunos operadores numéricos para este argumento son:

    -   `>`, `<` mayor que, y menor que
    -   `>=`, `=<` mayor o igual que, y menor o igual que
    -   `!=`, diferente a
    -   `==`, igual a

-   También puede utilizar operadores booleanos como:

    -   `&` and
    -   `|` or
    -   `!` no o negacion

**Ejercicio 1**: Seleccionar personas o filas de la sección 11.

```{r}
filter(Datos_Diversos_rename, Seccion=="11")
```

**Ejercicio 2**: Seleccionar personas con edad mayor e igual a 28.

```{r}
filter(Datos_Diversos_rename, Edad>=28)
```

**Ejercicio 3**: Seleccionar personas que sean del signo piscis.

```{r}
# unique, me permite ver todas las opciones únicas de una variable
unique(Datos_Diversos_rename$Signo)
```

```{r}
filter(Datos_Diversos_rename
       ,Signo=="pisics" | Signo=="Pisicis" | Signo=="Picis" | Signo=="Pisis" | Signo=="piscis")
```

**Ejercicio 4**: Seleccionar personas que sean del signo piscis con edades de 18 o 21 años.

```{r}
# Forma 1
filter(Datos_Diversos_rename
       ,Signo=="pisics" | Signo=="Pisicis" | Signo=="Picis" | Signo=="Pisis" | Signo=="piscis"
       ,Edad==18 | Edad==21)
```

El argumento `%in%` el cual funciona como una reducción de varios operadores lógicos `or`. Para estructuras más complejas recomiendo utilizar la segunda forma.

```{r}
#Forma 2
filter(Datos_Diversos_rename,
      Signo %in% c("pisics", "Pisicis", "Picis", "Pisis", "piscis"),
      Edad %in% c(18,21)
      )
```

# Limpieza de los datos

Cantidad de casos o filas completas

```{r}
sum(complete.cases(Datos_Diversos_rename))
```

Cantidad de NA o datos vacíos en cada columna

```{r}
colSums(is.na(Datos_Diversos_rename))
```

Porcentaje de registros NA

```{r}
sum(is.na(Datos_Diversos_rename))/(ncol(Datos_Diversos_rename)*nrow(Datos_Diversos_rename))*100
```

El 10.07% de los registros son NA

```{r}
Datos_Diversos_2 <- Datos_Diversos_rename
```

Porcentaje de registros NA, Datos_Diversos_2

```{r}
sum(is.na(Datos_Diversos_2))/(ncol(Datos_Diversos_2)*nrow(Datos_Diversos_2))*100
```

El 10.07987% de los registros son NA.

Tamaño de **muestra efectiva** por variable en `Datos_Diversos_2`

```{r}
muestra <- colSums(!is.na(Datos_Diversos_2))
muestra
```

```{r}
barplot( muestra
        ,main = "Muestra efectiva por variable"
        ,ylab = "Frecuencia"
        ,las = 3    # Sentido vertical del los nombres del eje x
        ,cex.names = 0.8  #Tamaño de las etiquetas en el eje x
        ,horiz = FALSE
        ,col = c(1,2,3,4,5,6,7,8,9,10,11,12,13,14,"#9932CC","#8B814C","green","#FF3030")
)
```

**Paleta de colores**:\
https://r-charts.com/es/colores/\
https://myrbooksp.netlify.app/graph2.html

Hallando el porcentaje de casos o filas completas

```{r}
round(sum(complete.cases(Datos_Diversos_2)) / nrow(Datos_Diversos_2) *100 ,2)
```

El 43.13% de los filas están completas.

## Sexo

```{r}
table(Datos_Diversos_2$Sexo, useNA = "always")
```

```{r}
unique(Datos_Diversos_2$Sexo)
```

Aquí podríamos intentar corregir algunos errores, siempre y cuando estemos claros que estamos haciendo manipulación de datos.

```{r}
Datos_Diversos_2$Sexo[Datos_Diversos_2$Sexo == "mM"] <- "M"
Datos_Diversos_2$Sexo[Datos_Diversos_2$Sexo == "m"] <- "M"
Datos_Diversos_2$Sexo[Datos_Diversos_2$Sexo == "NB"] <- "M"
Datos_Diversos_2$Sexo[Datos_Diversos_2$Sexo == 70] <- "M"
```

```{r}
table(Datos_Diversos_2$Sexo, useNA = "always")
```

```{r}
# Filtrar
filter(Datos_Diversos_2, Sexo == 70)
```

```{r}
table(Datos_Diversos_2$Sexo)
```

```{r}
# Diagrama de barras
barplot(table(Datos_Diversos_2$Sexo)
        ,ylab = "Frecuencia"
        ,col = c("red","yellow")
        )
```

```{r}
# Grafico de Pie
pie(table(Datos_Diversos_2$Sexo)
        ,col = c("red","yellow")
        )
```

## Estatura (cm)

```{r}
summary(Datos_Diversos_2$Estatura)
```

```{r}
# Histograma: Grafico para variables cuantitativas continuas
hist(Datos_Diversos_2$Estatura)
```

Revisando a los "enanitos"

```{r}
# Cantidad de registros menores de 50
sum(Datos_Diversos_2$Estatura < 50, na.rm = T)
```

```{r}
Datos_Diversos_2$Estatura[Datos_Diversos_2$Estatura < 50  & !is.na(Datos_Diversos_2$Estatura)] <- Datos_Diversos_2$Estatura[Datos_Diversos_2$Estatura < 50  & !is.na(Datos_Diversos_2$Estatura)]*100
```

```{r}
summary(Datos_Diversos_2$Estatura)
```

```{r}
sum(Datos_Diversos_2$Estatura > 250, na.rm = T)
```

```{r}
Datos_Diversos_2$Estatura[Datos_Diversos_2$Estatura == 300] <- 200
```

```{r}
summary(Datos_Diversos_2$Estatura)
```

```{r}
hist(Datos_Diversos_2$Estatura)
```

```{r}
caja <- boxplot(Datos_Diversos_2$Estatura)
```

```{r}
# Listando los outliers
caja$out
```

## Signo

```{r}
# Tabla ordenada de mayor a menor
sort(table(Datos_Diversos_2$Signo, useNA = "always"), decreasing = TRUE)
```

Ordenara la tabla por orden de frecuencia nos permite atacar los problemas más grandes primero.

Vamos a hacer la limpieza con cuidado, trabajando primero sobre una copia y actualizando los cambios cuando estemos seguros.

```{r}
# Creando una copia
signo_limpio <- Datos_Diversos_2$Signo
```

Cantidad de signos

```{r}
# Cantidad de valores que tiene la variable signo
length(unique(signo_limpio))
```

```{r}
# Reemplaza las vocales con acento por sin acento
signo_limpio <- chartr("áéíóú", "aeiou", signo_limpio)
length(unique(signo_limpio))
```

```{r}
# Convertir todo a minúscula
signo_limpio <- tolower(signo_limpio)
length(unique(signo_limpio))
```

```{r}
sort(table(signo_limpio, useNA = "always"), decreasing = T)
```

```{r}
# Buscar usando patrones de palabras
unique(signo_limpio[grep("gem", signo_limpio)])
```

```{r}
signo_limpio[grep("pis", signo_limpio)] <- "piscis"
signo_limpio[grep("cap", signo_limpio)] <- "capricornio"
signo_limpio[grep("leo", signo_limpio)] <- "leo"
signo_limpio[grep("escor", signo_limpio)] <- "escorpio"
signo_limpio[grep("gem", signo_limpio)] <- "geminis"
```

```{r}
# Reemplazo usando valores puntuales o específicos
signo_limpio[signo_limpio == "ofiuco"] <- NA
signo_limpio[signo_limpio == "desconocido"] <- NA
signo_limpio[signo_limpio == 170] <- NA
signo_limpio[signo_limpio == "-"] <- NA
signo_limpio[signo_limpio == "sagitatio"] <- "sagitario"
signo_limpio[signo_limpio == "arias"] <- "aries"
signo_limpio[signo_limpio == "picis"] <- "piscis"
```

```{r}
sort(table(signo_limpio, useNA = "always"), decreasing = T)
length(unique(signo_limpio))
```

```{r}
signo_limpio[is.na(signo_limpio)] <- "SinDatos"
```

```{r}
# Comprobando
 sort(table(signo_limpio, useNA = "always"), decreasing = T)
```

```{r}
tabla_signo <- sort(round(prop.table(table(signo_limpio))*100, 2), decreasing = T)
tabla_signo
```

```{r}
barplot(tabla_signo)
```

```{r}
barras <- barplot(tabla_signo
                  ,las = 3        # Dirección vertical de los nombres eje x
                  ,cex.names = 0.8     # Tamaño de los valores del eje x
                  ,cex.axis = 0.8     # Tamaño de los valores del eje y
                  ,ylab = "Observaciones"  # Nombre del eje y
                  ,main = "Signos del zodiaco" # Titulo
                  ,col = c(1,2,3,4,5,6,7,8,"red","blue","green","orange","white")
                  ,ylim = c(0,12)
                  )

text(x = barras
     ,y = tabla_signo
     ,label = tabla_signo
     ,cex = 0.8
     ,pos = 3
     ,col = "blue")
```

```{r}
# Reemplazando la variable Signo por los datos corregidos
Datos_Diversos_2$Signo <- signo_limpio
table(Datos_Diversos_2$Signo)
```

## Carrera

Total de carreras llenadas por los alumnos

```{r}
length(table(Datos_Diversos_2$Carrera))
```

Considerando que UTEC tiene cerca de 12 carreras, podemos ver que tenemos un problema.

```{r}
unique(Datos_Diversos_2$Carrera)
```

```{r}
sort(table(Datos_Diversos_2$Carrera, useNA = "always"), decreasing = T)
```

Ordenara la tabla por orden de frecuencia nos permite atacar los problemas más grandes primero.

Vamos a hacer la limpieza con cuidado, trabajando primero sobre una copia y actualizando los cambios cuando estemos seguros.

Convirtiendo todo en minúscula usando la función `tolower`

```{r}
CarreraLimpia <- Datos_Diversos_2$Carrera
```

```{r}
CarreraLimpia <- tolower(CarreraLimpia)  #Convirtiendo todo en minúscula
length(table(CarreraLimpia))
```

Hemos disminuido el numero de carreras.

Vamos a quitar todas las tildes y las colocaremos correctamente más tarde. Para eso usaremos la función `chartr`.

```{r}
CarreraLimpia <- chartr("áéíóú", "aeiou", CarreraLimpia)
length(table(CarreraLimpia))
```

Hemos disminuido las carreras aun mas

```{r}
sort(table(CarreraLimpia, useNA = "always"), decreasing = T)
```

Ahora vamos a usar la función `grep` para corregir patrones un poco más complicados.

La función `grep` y sus variantes como `gsub` trabajan con expresiones regulares para encontrar patrones interesantes en las cadenas de caracteres.

Hay que saber un poco sobre expresiones regulares. Revisar la ayuda de `grep` para más información.

```{r}
unique(CarreraLimpia[grep("^ing.*[\\.\\ ,]", CarreraLimpia)])
```

Hay casos de carreras que comienzan por las letras "ing" y eventualmente llegan a un espacio, un punto o una coma.

```{r}
unique(gsub("^ing*[\\.\\,]", "", CarreraLimpia))
```

```{r}
CarreraLimpia <- gsub("^ing.*[\\.\\,]", "", CarreraLimpia)
length(table(CarreraLimpia, useNA = "always"))
```

Hemos reducido mas las carreras.

```{r}
sort(table(CarreraLimpia, useNA = "always"), decreasing = T)
```

Identifico el patrón

```{r}
unique(CarreraLimpia[grep("mecat", CarreraLimpia)])
```

```{r}
CarreraLimpia[grep("bio", CarreraLimpia)] <- "bioingenieria"
CarreraLimpia[grep("comput", CarreraLimpia)] <- "ciencia de la computacion"
CarreraLimpia[grep("elec", CarreraLimpia)] <- "electronica"
CarreraLimpia[grep("ambie", CarreraLimpia)] <- "ambiental"
CarreraLimpia[grep("mecan", CarreraLimpia)] <- "mecanica"
CarreraLimpia[grep("civi", CarreraLimpia)] <- "civil"
CarreraLimpia[grep("mecat", CarreraLimpia)] <- "mecatronica"
CarreraLimpia[grep("energ", CarreraLimpia)] <- "energia"
CarreraLimpia[grep("quimi", CarreraLimpia)] <- "quimica"
CarreraLimpia[grep("indu", CarreraLimpia)] <- "industrial"
CarreraLimpia[grep("datos", CarreraLimpia)] <- "ciencia de datos"
CarreraLimpia[grep("meatronica", CarreraLimpia)] <- "mecatronica"
```

Reemplazar usando palabras puntuales

```{r}
CarreraLimpia[CarreraLimpia == "cs"] <- "ciencia de la computacion"
CarreraLimpia[CarreraLimpia == "leo"] <- NA
#CarreraLimpia[CarreraLimpia == ""] <- NA
```

Comprobar el avance de los reemplazos

```{r}
length(table(CarreraLimpia, useNA = "always"))
sort(table(CarreraLimpia, useNA = "always"), decreasing = T)
```

Aparentemente la variable Carrera estaría limpia.

Veamos que las cosas quedaron bien:

```{r}
DataPrueba <- data.frame(Datos_Diversos_2$Carrera, CarreraLimpia)
DataPrueba
```

```{r}
tablaCarr <- sort(table(CarreraLimpia, useNA = "always"), decreasing = T)
tablaCarr
```

```{r}
barplot(tablaCarr)
```

```{r}
GrafBarras <- barplot(tablaCarr
                      ,las = 3
                      ,cex.names = 0.8
                      ,cex.axis = 0.8
                      ,ylab = "Observaciones"
                      ,main = "Carreras - Datos diversos"
                      ,col = c(rep("gray",10),"red")
                      ,ylim = c(0,230)    )
              
text(x=GrafBarras
     ,y=tablaCarr
     ,label = tablaCarr
     ,cex = 0.8
     ,col = "brown"
     ,pos = 3)

legend("topright"   # Lugar donde estara la leyenda
       ,legend = c("Datos completos","Datos vacios")
       ,fill = c("gray","red")
       ,bty = "n"
       ,cex = 0.8  )
```

Podemos suponer que la variable `Carrera` está suficientemente limpia y oficializamos los cambios.

```{r}
Datos_Diversos_2$Carrera <- CarreraLimpia
table(Datos_Diversos_2$Carrera, useNA = "always")
```

```{r}
Datos_Diversos_2 <- mutate_at(Datos_Diversos_2, c("Carrera"), ~replace(.,is.na(.), "SinDatos")) #Renombra los NA
table(Datos_Diversos_2$Carrera, useNA = "always")
```

## Variable Peso

Convirtiendo la variable de `chr` a `num`

```{r}
str(Datos_Diversos_2$Peso)
```

```{r}
unique(Datos_Diversos_2$Peso)
```

```{r}
Datos_Diversos_2$Peso[Datos_Diversos_2$Peso == "90k"] <- 90
unique(Datos_Diversos_2$Peso)
```

```{r}
Datos_Diversos_2$Peso <- as.numeric(Datos_Diversos_2$Peso)
str(Datos_Diversos_2$Peso)
```

## Variable Codigo

Convirtiendo la variable de `mun` a `chr`

```{r}
str(Datos_Diversos_2$Codigo)
```

```{r}
Datos_Diversos_2$Codigo <- as.character(Datos_Diversos_2$Codigo)
str(Datos_Diversos_2$Codigo)
```

# Eliminando o Filtrando los NA nen una columna

```{r}
sum(is.na(Datos_Diversos_2$Codigo))
```

```{r}
# NOOOOOOOOOOO FILTRA NA
filter(Datos_Diversos_2, Codigo == NA)

```

```{r}
# FORMA CORRECTA DE FILTRAR NA
filter(Datos_Diversos_2, is.na(Codigo) == TRUE)
```

```{r}
library(dplyr)
Datos_Diversos_3 <- filter(Datos_Diversos_2, is.na(Codigo) == FALSE)
sum(is.na(Datos_Diversos_3$Codigo)) # Cantidad de datos nulos en la variable Codigo

```

```{r}
filter(Datos_Diversos_2, Codigo != "201910052")
```
